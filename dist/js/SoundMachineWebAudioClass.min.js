class t{constructor(t,i=1,o=!1){this.file=t,this.arrayBuffer=null,this.soundBuffer=null,this.soundSource=null,this.audioContext=null,this.gainNode=null,this._initialVolume=i,this._loop=o}async load(){const t=await fetch(this.file);this.arrayBuffer=await t.arrayBuffer()}async decode(t){this.audioContext=t,this.soundBuffer=await this.audioContext.decodeAudioData(this.arrayBuffer.slice(0)),this.gainNode=this.audioContext.createGain(),this.gainNode.gain.value=this._initialVolume}connect(){const t=this.audioContext.createBufferSource();return t.buffer=this.soundBuffer,this.gainNode.connect(this.audioContext.destination),t.loop=this._loop,t.connect(this.gainNode),t.onended=()=>{console.log(`${this.file} sound has ended`,this.audioContext.currentTime),this._loop||(t.disconnect(),console.log(`${this.file} sound has been disconnected`,this.audioContext.currentTime))},t}play(){null==this.soundSource&&(this.soundSource=this.connect()),this.gainNode.gain.value=this._initialVolume,this.soundSource.start(0)}fade(){this.volume=.001}stop(){this.soundSource.stop(),this.soundSource=null}get volume(){return this.gainNode.gain.value}set volume(t){0===t&&(t=.001);let i=this.volume;if(t===i)return;const o=i<t?"up":"down";console.log(`ramp ${o} ${this.file} sound volume from ${i} to ${t}`),this.gainNode.gain.exponentialRampToValueAtTime(t,this.audioContext.currentTime+("up"===o?1:6))}}export class SoundMachine{constructor(){this.audioContext=null,this.ticking=new t("/assets/audio/ticking.mp3",.8,!0),this.coin=new t("/assets/audio/coin.mp3"),this.laughs=new t("/assets/audio/guitar-string-snap2.mp3"),this.tada=new t("/assets/audio/tada.mp3"),this.fail=new t("/assets/audio/fail.mp3"),this.completed_with_errors=new t("/assets/audio/completed_with_errors.mp3"),this.boo=new t("/assets/audio/boo.mp3"),this.guitar=new t("/assets/audio/guitar-riff.mp3"),this.boredom=new t("/assets/audio/boredom.mp3"),this.underwater=new t("/assets/audio/underwater.mp3",.001,!0),this.abort=new t("/assets/audio/short-whoosh.mp3")}loadAndInitializeResources(){return new Promise((async(t,i)=>{try{await this.ticking.load(),await this.coin.load(),await this.laughs.load(),await this.tada.load(),await this.fail.load(),await this.completed_with_errors.load(),await this.boo.load(),await this.guitar.load(),await this.boredom.load(),await this.underwater.load(),await this.abort.load(),this.audioContext?console.warn("Audio context is already initialized"):this.audioContext=new(window.AudioContext||window.webkitAudioContext);let i=0;await this.ticking.decode(this.audioContext),++i,await this.coin.decode(this.audioContext),++i,await this.laughs.decode(this.audioContext),++i,await this.tada.decode(this.audioContext),++i,await this.fail.decode(this.audioContext),++i,await this.completed_with_errors.decode(this.audioContext),++i,await this.boo.decode(this.audioContext),++i,await this.guitar.decode(this.audioContext),++i,await this.boredom.decode(this.audioContext),++i,await this.abort.decode(this.audioContext),++i,await this.underwater.decode(this.audioContext),++i,console.log(`Audio context initialized successfully, ${i} sound sources connected`),t()}catch(t){console.error("Error initializing audio:",t),i(t)}}))}}